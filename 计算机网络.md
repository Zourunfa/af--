![image-20210313101055448](C:\Users\47302\AppData\Roaming\Typora\typora-user-images\image-20210313101055448.png)







![image-20210328110251464](C:\Users\47302\AppData\Roaming\Typora\typora-user-images\image-20210328110251464.png)

1. **物理层** 二进制的传输  中继器和集线器
2. **数据链路层**  传送以帧为单位的信息  PPTP PPP L2TP SLIP
3. **网络层**    分组传输和路由选择   ARP RAP  IP ICMP IGMP
4. **运输层**   TCP UDP
5. **应用层**    SMTP DNS



SMTP ：SMTP是一种提供可靠且有效的[电子邮件传输](https://baike.baidu.com/item/电子邮件传输/22035911)的协议

SNMP：简单网络管理协议（[SNMP](https://baike.baidu.com/item/SNMP/133378)） 是专门设计用于在 IP 网络管理[网络节点](https://baike.baidu.com/item/网络节点/9338583)

Telnet:  Telnet是一种简单的基于文本的网络协议，用于通过“TCP/IP”网络访问远程计算机和终端；telnet为用户提供了一个双向的交互式文本通信系统，该系统使用超过8字节的虚拟终端连接。

IGMP:   Internet 组管理协议称为IGMP协议

ICMP（Internet Control Message Protocol）Internet控制[报文](https://baike.baidu.com/item/报文/3164352)协议。



## UDP

> UDP 是⼀个⾯向报⽂（报⽂可以理解为⼀段段的数据）的协议。意思就是
>
> UDP 只是报⽂的搬运⼯，不会对报⽂进⾏任何拆分和拼接操作 

- 在发送端，应⽤层将数据传递给传输层的 UDP 协议， UDP 只会给数据增加⼀个 UDP头标识下是 UDP 协议，然后就传递给⽹络层了 
- 在接收端，⽹络层将数据传递给传输层， UDP 只 去除 IP 报⽂头就传递给应⽤层，不会任何拼接操作



**不可靠性**

1. UDP是无连接的协议，所以通信不需要建立和断开链接
2. UDP是不可靠的。协议收到什么数据就传递什么数据，并且也不会备份数据
3. UDP没有拥塞控制，一直会以恒定的速度发送数据，即使网络条件不好，也不会对发送数据做调整

**高效**

1. UDP的头部只有8字节，而tcp有20字节，所以开销较小，传输数据报文是高效
2. 头部包含了两个16位的端口号，分别为源端口和目标端口，整个数据报文的长度
3. UDP不支持一对一的传输方式，提供了单播，广播功能

（1）慢启动

每当建立一个TCP连接时或一个TCP连接发生超时重传后，该连接便进入慢启动阶段。进入慢启动后，TCP实体将拥塞窗口的大小初始化为一个报文段，即：cwnd=1。此后，每收到一个报文段的确认（ACK），cwnd值加1，即拥塞窗口按指数增加。当cwnd值超过慢启动阐值（ssthresh）或发生报文段丢失重传时，慢启动阶段结束。前者进入拥塞避免阶段，后者重新进入慢启动阶段。

（2）拥塞避免

在慢启阶段，当cwnd值超过慢启动阐值（ssthresh）后，慢启动过程结束，TCP连接进入拥塞避免阶段。在拥塞避免阶段，每一次发送的cwnd个报文段被完全确认后，才将cwnd值加1。在此阶段，cwnd值线性增加。

（3）快速重传

快速重传是对超时重传的改进。当源端收到对同一个报文的三个重复确认时，就确定一个报文段已经丢失，因此立刻重传丢失的报文段，而不必等到重传定时器（RTO）超时。以此减少不必要的等待时间。

（4）快速恢复

快速恢复是对丢失恢复机制的改进。在快速重传之后，不经过慢启动过程而直接进入拥塞避免阶段。每当快速重传后，置ssthresh=cwnd/2、ewnd=ssthresh+3。此后，每收到一个重复确认，将cwnd值加1，直至收到对丢失报文段和其后若干报文段的累积确认后，置cwnd=ssthresh，进入拥塞避免阶段。



## TCP

**头部**

TCP头部比UDP的头部要复杂的多



- **Seq**uence number ，这个序号保证了 **TCP 传输的报⽂都是有序的，对端可以通过序号 顺序的拼接报⽂**
- **Ack**nowledgement Number ，这个序号表示**数据接收端期望接收的下⼀个字节的编号**是多 少，同时也表示上⼀个序号的数据已经收到
- Window Size ，窗⼝⼤⼩，表示还能接收多少字节的数据，⽤于流量控制 



**标识符**



**URG=1** ：该字段为⼀表示本数据报的数据部分包含紧急信息，是⼀个⾼优先级数据报⽂， 

此时紧急指针有效。紧急数据⼀定位于当前数据包数据部分的最前⾯，紧急指针标明了紧 急数据的尾部。

**RST=1** ：该字段为⼀表示当前 TCP 连接出现严重问题，可能需要重新建⽴ TCP 连 接，也可以⽤于拒绝⾮法的报⽂段和拒绝连接请求。

**ACK=1** ：该字段为⼀表示**确认号字段**有效。此外， TCP 还规定在连接建⽴后传送的所有 报⽂段都必须把 ACK 置为⼀ PSH=1 ：该字段为⼀表示接收端应该⽴即将数据 push 给应 ⽤层，⽽不是等到缓冲区满后再提交

**SYN=1** ：**当 SYN=1 ， ACK=0 时，表示当前报⽂段是⼀个连接请求报⽂。当 SYN=1 ，ACK=1 时，表示当前报⽂段是⼀个同意建⽴连接的应答报⽂。**

FIN=1 ：该字段为⼀表示此报⽂段是⼀个**释放连接的请求报⽂** 



**关于tcp的面向链接**

“连接”：这个连接并不是真正意义上的连接，称之为“虚电路”，其实也并不是说A和B之间震荡建立了一条连接，或者说保证了路由路径是一致的，因为路由选择并不是传输层控制的，传输层负责流量控制和差错控制，因此所有的拥塞控制和路由选择其实是IP协议的工作，所以说，TCP怎能保证路由路径是一样的呢，如果出现网络拥堵，必然会重新选择路径。那么这个连接究竟是什么呢？

答案是：状态和序列号，以及错误校验（可以查看TCP和UDP的请求头，就会发现两者之间的差距了），**其实所谓的TCP三次握手请求连接，无非就是初始化一个序列号，保证后面的数据有序到达**，同时TCP还支持重传，错误校验，保证数据的可靠性，当然UDP也提供校验。




## 三次握手

- 第一次客户端主动请求建立链接，创建传输控制块之后向tcp服务器发送tcp链接请求，其中请求报文段的同步为被设为1，表明是一个链接请求报文段，seq字段被设为x，作为tcp客户进程所选择的初始序号

- 第二次是在服务器收到请求后，同意建立链接，就会向客户端发送链接请求确认报文段，进入同步已接收的状态，且确认报文段，syn被置为1，确认位是1，表明是一个确认报文段，seq被设置为一个初始值y,表明是tcp服务进程所选择的一个初始序号，确认号ack被设置为x+1
- 再次握手是tcp客户端收到链接请求确认后，tcp客户发送一个普通的tcp确认报文段，并进入链接已建立的状态ACK=1，表明这是一个普通的tcp确认报文段，seq=x+1 ack=y+1这是对tcp服务器所选的初始信号y的确认，之后就是服务器也建立链接状态，可以进行数据传输

### 你是否有疑惑明明两次握⼿就可以建⽴起连接，为什么还需要第三次应答？ 

**因为这是为了防⽌失效的连接请求报⽂段被服务端接收，从⽽产⽣错误** 

> 可以想象如下场景。客户端发送了⼀个连接请求 A，但是因为⽹络原因造成了 
>
> 超时，这时 TCP 会启动**超时重传的机制**再次发送⼀个连接请求 B。此时请求顺
>
> 利到达服务端，服务端应答完就建⽴了请求。如果连接请求 A 在两端关闭后终 
>
> 于抵达了服务端，那么这时服务端会认为客户端⼜需要建⽴ TCP 连接，从⽽ 
>
> 应答了该请求并进⼊ ESTABLISHED 状态。此时客户端其实是 CLOSED 状 
>
> 态，那么就会导致服务端⼀直等待，造成资源的浪费 

## 四次挥手

> 客户端和服务器是都可以释放链接的

- 第一次：若客户主动关闭，会向服务器发送链接释放的请求，FIN=1不携带数据也要消耗一个序号,(ACK=1,seq=u)
- 第二次：主机收到后会发送一个普通的tcp确认报文段，并进入关闭等待的状态，在发送一个tcp确认报文段，tcp服务进程会通知高层应用进程客户，此时的tcp处于半关闭的状态，客户进程没有数据发送，但是tcp服务进程还可以发送数据（ACK）
- 第三次：服务器此时还有没发完的数据会继续发送，完毕后会向A发送链接释放请求，然后B变进入LAST-ACK状态
- 第四次，客户端收到适当请求后，向服务器发送确认应答，**此时客户端处于等待的状态，在等待的生存期过了之后一直没有向服务器发送请求的话，就会进入关闭状态，**当服务器，收到确认应答后也会进入关闭的状态





## HTTP

> http协议是个无状态的协议，不会保存状态





### 常见状态码

**2xx **  **成功**

- 200 表示客户端发来的请求在服务器端被正确的处理

- 204 No content 表示请求成功，但响应报文不含实体的主体部分

- 205 Reset Content ，表示请求成功，但响应报⽂不含实体的主体部分，但是与 204响应不同在于要求请求⽅重置内容

- 206 Partial Content ，进⾏范围请求 

  ​                                            

**3XX**  **重定向**

- 301 永久性的重定向，资源被分配了新的URL

- 302 临时性的重定向

- 303 表示资源存在另一个URL，应该使用Get方法定向获取资源

- 304 表示服务器允许访问资源

- 307  临时重定向，和302含义类似，但是期望客户端保持请求⽅ 

  法不变向新的地址发出请求 

**4XX**  **客户端错误**

- 400 bad request ，请求报⽂存在语法错误
- 401 unauthorized ，表示发送的请求需要有通过 HTTP 认证的认证信息
- 403 forbidden ，表示对请求资源的访问被服务器拒绝
- 404 not found ，表示在服务器上没有找到请求的资源 

**5XX 服务器错误**

- 500 internal sever error ，表示服务器端在执⾏请求时发⽣了错误
- 501 Not Implemented ，表示服务器不⽀持当前请求所需要的某个功能
- 503 ("Bad Gateway") ，只有HTTP代理会发送这个响应代码。它表明代理方面出现问题，或者代理与上行服务器之间出现问题，而不是上行服务器本身有问题。若代理根本无法访问上行服务器，响应代码将是504。
- 503 service unavailable ，表明服务器暂时处于超负载或正在停机维护，⽆法处理请 求



## HTTP ⾸部

![image-20210313195703675](C:\Users\47302\AppData\Roaming\Typora\typora-user-images\image-20210313195703675.png)

![image-20210313195715753](C:\Users\47302\AppData\Roaming\Typora\typora-user-images\image-20210313195715753.png)

![image-20210313195747068](C:\Users\47302\AppData\Roaming\Typora\typora-user-images\image-20210313195747068.png)

![image-20210313195812790](C:\Users\47302\AppData\Roaming\Typora\typora-user-images\image-20210313195812790.png)

![image-20210313195826342](C:\Users\47302\AppData\Roaming\Typora\typora-user-images\image-20210313195826342.png)

## http强制缓存

浏览器在初次请求成功的时候，服务器会返回资源，并且在Response Header中携带Cache-control,并把资源存储到本地缓存，再次请求的时候，如果cache-control中的max-age还没有到期，就会直接到本地缓存拿到资源。

![image-20210314191327052](C:\Users\47302\AppData\Roaming\Typora\typora-user-images\image-20210314191327052.png)

## cache-control有哪些值

在Response Header中

- max-age:缓存的最大过期时间
- no-cache:不用本地缓存，正常的去服务端去请求(不用强制缓存)
- no-store:即不用强制缓存，也不用协商缓存（不常见）
- private:只能允许最终用户缓存
- 可以允许中间代理做缓存



## Expires

在Response Header中，控制缓存过期，已经被cache-control代替



## HTTP协商缓存

- 服务端的缓存策略（并不是服务端缓存，只是服务端告诉客户端你这个资源没有动，你直接用本地的资源就可以了，所以服务端并没有返回任何新的资源，所以还是加快效率，节省消耗了）
- 服务器判断客户端的资源，是否和服务器的资源一样
- 如果判断一致，就返回304，否则返回200和最新的资源

![image-20210314192643363](C:\Users\47302\AppData\Roaming\Typora\typora-user-images\image-20210314192643363.png)







### 资源标志

- 在Response Header中，有两种
- Last-Modified 资源的最后修改时间
- Etag资源的唯一标志(一个字符串，类似人类的指纹)



![image-20210314193832714](C:\Users\47302\AppData\Roaming\Typora\typora-user-images\image-20210314193832714.png)

![image-20210314194000449](C:\Users\47302\AppData\Roaming\Typora\typora-user-images\image-20210314194000449.png)

- 会优先用Etag
- Last-Modified的只能精确到秒级
- 如果资源被重复生成，而内容不变，则Etag更加精确



![image-20210314194239107](C:\Users\47302\AppData\Roaming\Typora\typora-user-images\image-20210314194239107.png)

![image-20210314200802856](C:\Users\47302\AppData\Roaming\Typora\typora-user-images\image-20210314200802856.png)

正常操作就是，直接输入url，或者点击url，前进后退

手动刷新就是 F5

强制刷新就是 Ctrl+F5





## xss攻击

![image-20210314201052288](C:\Users\47302\AppData\Roaming\Typora\typora-user-images\image-20210314201052288.png)

![image-20210314201156010](C:\Users\47302\AppData\Roaming\Typora\typora-user-images\image-20210314201156010.png)

## CSRF

> 跨站请求伪造：就是攻击者通过伪造你的身份，来向其他第三方网站发送请求

CSRF攻击是源于WEB的隐式身份验证机制！WEB的身份验证机制虽然可以保证一个请求是来自于某个用户的浏览器，但却无法保证该请求是用户批准发送的！



![image-20210412085655484](C:\Users\47302\AppData\Roaming\Typora\typora-user-images\image-20210412085655484.png)



　从上图可以看出，要完成一次CSRF攻击，受害者必须依次完成两个步骤：

　　1.登录受信任网站A，并在本地生成Cookie。

　　2.在不登出A的情况下，访问危险网站B。



### **CSRF的防御**

**服务端进行CSRF防御**

> 　服务端的CSRF方式方法很多样，但总的思想都是一致的，就是在客户端页面增加伪随机数。

(1),Cookie Hashing(所有表单都包含同一个伪随机值)：

这可能是最简单的解决方案了，因为攻击者不能获得第三方的Cookie(理论上)，所以表单中的数据也就构造失败了:>



(2).验证码

这个方案的思路是：**每次的用户提交都需要用户在表单中填写一个图片上的随机字符串，厄....这个方案可以完全解决CSRF，但个人觉得在易用性方面似乎不是太好，还有听闻是验证码图片的使用涉及了一个被称为MHTML的Bug，**可能在某些版本的微软IE中受影响。





　(3).One-Time Tokens(不同的表单包含一个不同的伪随机值)

在实现One-Time Tokens时，需要注意一点：就是“并行会话的兼容”。如果用户在一个站点上同时打开了两个不同的表单，CSRF保护措施不应该影响到他对任何表单的提交。考虑一下如果每次表单被装入时站点生成一个伪随机值来覆盖以前的伪随机值将会发生什么情况：用户只能成功地提交他最后打开的表单，因为所有其他的表单都含有非法的伪随机值。必须小心操作以确保CSRF保护措施不会影响选项卡式的浏览或者利用多个浏览器窗口浏览一个站点。



## Get和post方法的区别

- get和post都是http协议下两种文件传输的方式
- 其实http协议本身没有的对get和post方法有数据长度的要求，这是浏览器的限制
- get的参数会暴露在url，post的参数也是明文，没有加密所以也不安全
- GET请求会被浏览器主动cache，而POST不会，除非手动设置
- GET请求只能进行url编码，而POST支持多种编码方式。
- GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。

3、GET和POST还有一个重大区别，简单的说：

**GET产生一个TCP数据包；POST产生两个TCP数据包**

**对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；**

**而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。**

也就是说，GET只需要汽车跑一趟就把货送到了，而POST得跑两趟，第一趟，先去和服务器打个招呼“嗨，我等下要送一批货来，你们打开门迎接我”，然后再回头把货送过去

## http

> 超文本传输协议，是一个基于请求与响应，无状态的，应用层的协议，常基于TCP/IP协议传输数据，互联网上应用最广泛的一种网络协议，所有的www文件都必须遵循这个标准，设计HTTP的初衷是为了提供一种发布和接收HTML页面的方法





## 对称加密和非对称加密

**对称加密**

- 加密方和解密方使用同一个秘钥，发送过程中容易被劫持，安全性差，但是速度快

**非对称加密**

加密和解密的过程中，秘钥成对出现，不使用同一份秘钥。公钥对数据进行加密，只有用对应的私钥才能解密

> 甲方生成一对[密钥](https://baike.baidu.com/item/密钥/101144)并将公钥公开，需要向甲方发送信息的其他角色(乙方)使用该密钥(甲方的公钥)对机密信息进行加密后再发送给甲方；甲方再用自己私钥对加密后的信息进行解密。甲方想要回复乙方时正好相反，使用乙方的公钥对数据进行加密，同理，乙方使用自己的私钥来进行解密



**非对称加密的缺点**

服务端只将公钥暴露，浏览器使用公钥对消息进行非对称加密，服务端用私钥解密。但是服务端向浏览器回复的时候，只能用私钥进行加密，浏览器只能用公钥解密。但是：公钥是所有人都知道的，所有人都可以读取服务端回复的消息来进行解密，所以**解决不了服务端向浏览器传递消息**。

## Https加密的选择

对称加密和非对称加密结合方式

1. 浏览器使用Https的URL访问服务器，建立SSL链接。
2. 服务器收到SSL链接，发送非对称加密的公钥A返回给浏览器
3. 浏览器生成随机数，作为对称加密的密钥B
4. 浏览器使用公钥A，对自己生成的密钥B进行加密，得到密钥C
5. 浏览器将密钥C，发送给服务器。
6. 服务器用私钥D对接受的密钥C进行解密，得到对称加密钥B。
7. 浏览器和服务器之间可以用密钥B作为对称加密密钥进行通信。
   

![image-20210330093345779](C:\Users\47302\AppData\Roaming\Typora\typora-user-images\image-20210330093345779.png)

什么是认证中心，**证书时如何签字的**

![image-20210330093446240](C:\Users\47302\AppData\Roaming\Typora\typora-user-images\image-20210330093446240.png)

